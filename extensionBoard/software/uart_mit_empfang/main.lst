   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  90               	.global	adc2res
  92               	adc2res:
   1:main.c        **** #define F_CPU 8000000L
   2:main.c        **** #define BAUD 9600L
   3:main.c        **** 
   4:main.c        **** #include <string.h>
   5:main.c        **** #include <avr/io.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include <util/delay.h>
   8:main.c        **** #include <stdlib.h>
   9:main.c        **** #include <stdio.h>
  10:main.c        **** #include <stdint.h>
  11:main.c        ****  
  12:main.c        ****  
  13:main.c        **** #define UBRR_VAL  ((F_CPU+BAUD*8)/(BAUD*16)-1)
  14:main.c        **** #define BAUD_REAL (F_CPU/(16*(UBRR_VAL+1)))
  15:main.c        **** #define BAUD_ERROR ((BAUD_REAL*1000)/BAUD-1000)
  16:main.c        **** #if ((BAUD_ERROR>10) || (BAUD_ERROR<-10))
  17:main.c        ****   #error Systematischer Fehler der Baudrate grösser 1% und damit zu hoch! 
  18:main.c        **** #endif
  19:main.c        **** 
  20:main.c        **** #define R_PC0 1000 // 1000 Ohm am Spannungsteiler von PC0
  21:main.c        **** /* Connection to PC0 :
  22:main.c        ****  ---------------+
  23:main.c        ****                 |         +- R_PC0 == 1000 Ohm --- +3.3v
  24:main.c        ****                 |         |
  25:main.c        ****                 --- PC0 --+
  26:main.c        ****                 |         |
  27:main.c        ****                 |         +- Temp-Sensor --------- GND
  28:main.c        ****                 |
  29:main.c        ****                 |
  30:main.c        **** */
  31:main.c        **** 
  32:main.c        **** #define uart_buffer_size 256
  33:main.c        **** 
  34:main.c        **** volatile uint8_t uart_rx_flag=0;            // Flag, String komplett empfangen
  35:main.c        **** volatile uint8_t uart_tx_flag=1;            // Flag, String komplett gesendet
  36:main.c        **** char uart_rx_buffer[uart_buffer_size];      // Empfangspuffer
  37:main.c        **** char uart_tx_buffer[uart_buffer_size];      // Sendepuffer
  38:main.c        **** 
  39:main.c        **** void put_string(char *daten) {
  40:main.c        ****    if (uart_tx_flag == 1) {
  41:main.c        ****       strcpy(uart_tx_buffer, daten);      
  42:main.c        ****       uart_tx_flag = 0;                    
  43:main.c        ****       UCSRB |= (1<<UDRIE); 
  44:main.c        ****    }
  45:main.c        **** }
  46:main.c        **** 
  47:main.c        **** void get_string(char *daten) {
  48:main.c        ****    if (uart_rx_flag==1) {
  49:main.c        ****       strcpy(daten, uart_rx_buffer);
  50:main.c        ****       uart_rx_flag = 0;
  51:main.c        ****    }
  52:main.c        **** }
  53:main.c        **** 
  54:main.c        **** void send_ok(){
  55:main.c        **** 	char message[4];
  56:main.c        **** 	message[0] = 'O';
  57:main.c        **** 	message[1] = 'K';
  58:main.c        **** 	message[2] = '\n';
  59:main.c        **** 	message[3] = '\r';
  60:main.c        **** 	put_string(message);
  61:main.c        **** }
  62:main.c        **** 
  63:main.c        **** int adc2res(int adcValue){
  94               	.LM0:
  95               	.LFBB1:
  96 0000 EF92      		push r14
  97 0002 FF92      		push r15
  98 0004 0F93      		push r16
  99 0006 1F93      		push r17
 100               	/* prologue: function */
 101               	/* frame size = 0 */
  64:main.c        **** 	int resistance;
  65:main.c        **** 	double adcVoltage = adcValue * 2.56f / 1023.0f;
 103               	.LM1:
 104 0008 AA27      		clr r26
 105 000a 97FD      		sbrc r25,7
 106 000c A095      		com r26
 107 000e BA2F      		mov r27,r26
 108 0010 BC01      		movw r22,r24
 109 0012 CD01      		movw r24,r26
 110 0014 00D0      		rcall __floatsisf
 111 0016 2AE0      		ldi r18,lo8(0x4023d70a)
 112 0018 37ED      		ldi r19,hi8(0x4023d70a)
 113 001a 43E2      		ldi r20,hlo8(0x4023d70a)
 114 001c 50E4      		ldi r21,hhi8(0x4023d70a)
 115 001e 00D0      		rcall __mulsf3
 116 0020 20E0      		ldi r18,lo8(0x447fc000)
 117 0022 30EC      		ldi r19,hi8(0x447fc000)
 118 0024 4FE7      		ldi r20,hlo8(0x447fc000)
 119 0026 54E4      		ldi r21,hhi8(0x447fc000)
 120 0028 00D0      		rcall __divsf3
 121 002a 7B01      		movw r14,r22
 122 002c 8C01      		movw r16,r24
 123 002e 63E3      		ldi r22,lo8(0x40533333)
 124 0030 73E3      		ldi r23,hi8(0x40533333)
 125 0032 83E5      		ldi r24,hlo8(0x40533333)
 126 0034 90E4      		ldi r25,hhi8(0x40533333)
 127 0036 A801      		movw r20,r16
 128 0038 9701      		movw r18,r14
 129 003a 00D0      		rcall __subsf3
 130 003c 9B01      		movw r18,r22
 131 003e AC01      		movw r20,r24
 132 0040 C801      		movw r24,r16
 133 0042 B701      		movw r22,r14
 134 0044 00D0      		rcall __divsf3
 135 0046 20E0      		ldi r18,lo8(0x447a0000)
 136 0048 30E0      		ldi r19,hi8(0x447a0000)
 137 004a 4AE7      		ldi r20,hlo8(0x447a0000)
 138 004c 54E4      		ldi r21,hhi8(0x447a0000)
 139 004e 00D0      		rcall __mulsf3
 140 0050 00D0      		rcall __fixsfsi
  66:main.c        **** 	resistance = R_PC0 * (adcVoltage / (3.3f - adcVoltage));
  67:main.c        **** 	return resistance;
  68:main.c        **** }
 142               	.LM2:
 143 0052 CB01      		movw r24,r22
 144               	/* epilogue start */
 145 0054 1F91      		pop r17
 146 0056 0F91      		pop r16
 147 0058 FF90      		pop r15
 148 005a EF90      		pop r14
 149 005c 0895      		ret
 151               	.Lscope1:
 154               	.global	res2temp
 156               	res2temp:
  69:main.c        **** 
  70:main.c        **** 
  71:main.c        **** double res2temp(int res){
 158               	.LM3:
 159               	.LFBB2:
 160               	/* prologue: function */
 161               	/* frame size = 0 */
 163               	.LM4:
 164 005e AA27      		clr r26
 165 0060 97FD      		sbrc r25,7
 166 0062 A095      		com r26
 167 0064 BA2F      		mov r27,r26
 168 0066 BC01      		movw r22,r24
 169 0068 CD01      		movw r24,r26
 170 006a 00D0      		rcall __floatsisf
 171 006c 20E0      		ldi r18,lo8(0x444bc000)
 172 006e 30EC      		ldi r19,hi8(0x444bc000)
 173 0070 4BE4      		ldi r20,hlo8(0x444bc000)
 174 0072 54E4      		ldi r21,hhi8(0x444bc000)
 175 0074 00D0      		rcall __subsf3
 176 0076 20E0      		ldi r18,lo8(0x40f00000)
 177 0078 30E0      		ldi r19,hi8(0x40f00000)
 178 007a 40EF      		ldi r20,hlo8(0x40f00000)
 179 007c 50E4      		ldi r21,hhi8(0x40f00000)
 180 007e 00D0      		rcall __divsf3
 181               	/* epilogue start */
  72:main.c        **** 	return (res - 815.0f) / 7.5f;
  73:main.c        **** }
 183               	.LM5:
 184 0080 0895      		ret
 186               	.Lscope2:
 188               	.global	__vector_11
 190               	__vector_11:
  74:main.c        **** 
  75:main.c        **** int main (void) {
  76:main.c        ****     char stringbuffer[64];  // Allgemeiner Puffer für Strings
  77:main.c        ****     uint8_t buffer_full=0;  // noch ein Flag, aber nur in der Hauptschleife
  78:main.c        ****     char * charpointer;     // Hilfszeiger
  79:main.c        **** 	int sampleValue = 0;
  80:main.c        **** 
  81:main.c        ****     // IO konfigurieren
  82:main.c        ****     DDRB = 0xFF;
  83:main.c        ****     DDRC = 0x00;
  84:main.c        **** 	PORTC = 0x00;
  85:main.c        ****     //DDRD = 0xFF;
  86:main.c        ****     //DDRD = (DDRD|0x01);
  87:main.c        **** 
  88:main.c        **** 	ADMUX = 0x00;
  89:main.c        **** 	ADMUX |= (1<<REFS1)| (1<<REFS0); // 0b01000000; // interne Ref-Spannung, avcc, pc0 als adc
  90:main.c        **** 	ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
  91:main.c        **** 
  92:main.c        **** 
  93:main.c        ****     // Servo konfigurieren
  94:main.c        ****     // Werte für OCR1A: zw. 650 und 1900!
  95:main.c        ****     /*
  96:main.c        ****     ICR1=10000;
  97:main.c        ****     TCCR1A|=(0<<COM1A0)|(1<<COM1A1)|(0<<COM1B0)|(0<<COM1B1)|(0<<FOC1A)|(0<<FOC1B)|(1<<WGM11)|(0<<WG
  98:main.c        ****     TCCR1B|=(0<<ICNC1)|(0<<ICES1)|(1<<WGM13)|(1<<WGM12)|(0<<CS12)|(1<<CS11)|(0<<CS10);
  99:main.c        ****     OCR1A = 1300;
 100:main.c        ****     */
 101:main.c        **** 
 102:main.c        ****     // UART konfigurieren
 103:main.c        ****     UBRRH = UBRR_VAL >> 8;
 104:main.c        ****     UBRRL = UBRR_VAL & 0xFF;
 105:main.c        ****     UCSRB = (1<<RXCIE) | (1<<RXEN) | (1<<TXEN); 
 106:main.c        **** 
 107:main.c        ****     UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);      //Asynchron 8N1
 108:main.c        **** 
 109:main.c        ****     // Stringpuffer initialisieren
 110:main.c        ****     //stringbuffer[0] = '\n';
 111:main.c        ****     //stringbuffer[1] = '\r';
 112:main.c        **** 
 113:main.c        ****     // Interrupts freigeben
 114:main.c        ****     sei();
 115:main.c        **** 
 116:main.c        ****     while(1) {
 117:main.c        **** 
 118:main.c        **** 
 119:main.c        ****         if (uart_rx_flag==1 && buffer_full==0) {
 120:main.c        ****             get_string(stringbuffer);
 121:main.c        ****             buffer_full=1;
 122:main.c        ****         }
 123:main.c        **** 
 124:main.c        **** 	/*
 125:main.c        **** 	 * zum testen, falls "S1" gesendet wurde,
 126:main.c        **** 	 * schalte Pin C0 ein
 127:main.c        **** 	 */
 128:main.c        **** 	if(stringbuffer[0] == 'S'){
 129:main.c        **** 		if(stringbuffer[1] == '1'){
 130:main.c        **** 			PORTC |= (1<<5);
 131:main.c        **** 			send_ok();
 132:main.c        **** 			// put other char in there to not trigger it again
 133:main.c        **** 			stringbuffer[0] = 'N';
 134:main.c        **** 			buffer_full = 0;
 135:main.c        **** 		}	
 136:main.c        **** 	}else if(stringbuffer[0] == 'U'){
 137:main.c        **** 		if(stringbuffer[1] == '1'){
 138:main.c        **** 			PORTC &= ~(1<<5);
 139:main.c        **** 			send_ok();
 140:main.c        **** 			stringbuffer[0] = 'N';
 141:main.c        **** 			buffer_full = 0;
 142:main.c        **** 		}
 143:main.c        **** 	}else if(stringbuffer[0] == 'G'){ // adc wert anfordern
 144:main.c        **** 		ADCSRA |= (1<<ADSC);  //single conversion mode ein
 145:main.c        **** 		while(ADCSRA & (1<<ADSC));  //warten bis konvertierung abgeschlosen
 146:main.c        **** 		sampleValue = ADCW;
 147:main.c        **** 		dtostrf( res2temp(adc2res(sampleValue)), 5, 2, stringbuffer );
 148:main.c        **** 		strcat(stringbuffer, "\n\r");
 149:main.c        **** 		_delay_ms(100);
 150:main.c        **** 		put_string(stringbuffer);
 151:main.c        **** 		buffer_full = 0;
 152:main.c        **** 	}else{
 153:main.c        **** 		_delay_ms(10);
 154:main.c        **** 
 155:main.c        **** 	        if (uart_tx_flag==1 && buffer_full==1) {
 156:main.c        **** 	            strcat(stringbuffer, "\n\r");
 157:main.c        **** 	            put_string(stringbuffer); // zurücksenden
 158:main.c        **** 	            buffer_full=0; // Buffer ist wieder verfügbar
 159:main.c        **** 	        }
 160:main.c        **** 	}
 161:main.c        ****     }
 162:main.c        **** }
 163:main.c        **** 
 164:main.c        **** ISR(USART_RXC_vect) {
 192               	.LM6:
 193               	.LFBB3:
 194 0082 1F92      		push __zero_reg__
 195 0084 0F92      		push r0
 196 0086 0FB6      		in r0,__SREG__
 197 0088 0F92      		push r0
 198 008a 1124      		clr __zero_reg__
 199 008c 8F93      		push r24
 200 008e 9F93      		push r25
 201 0090 EF93      		push r30
 202 0092 FF93      		push r31
 203               	/* prologue: Signal */
 204               	/* frame size = 0 */
 165:main.c        ****     static uint8_t uart_rx_cnt=0;     // Zähler für empfangene Zeichen
 166:main.c        ****     uint8_t data;
 167:main.c        **** 
 168:main.c        ****     data = UDR;
 206               	.LM7:
 207 0094 9CB1      		in r25,44-32
 169:main.c        **** 
 170:main.c        ****     if (!uart_rx_flag) {
 209               	.LM8:
 210 0096 8091 0000 		lds r24,uart_rx_flag
 211 009a 8823      		tst r24
 212 009c 01F4      		brne .L8
 213 009e 8091 0000 		lds r24,uart_rx_cnt.1709
 171:main.c        ****         if (data == '\r') {
 215               	.LM9:
 216 00a2 9D30      		cpi r25,lo8(13)
 217 00a4 01F4      		brne .L7
 172:main.c        ****             uart_rx_buffer[uart_rx_cnt]=0;
 219               	.LM10:
 220 00a6 E82F      		mov r30,r24
 221 00a8 F0E0      		ldi r31,lo8(0)
 222 00aa E050      		subi r30,lo8(-(uart_rx_buffer))
 223 00ac F040      		sbci r31,hi8(-(uart_rx_buffer))
 224 00ae 1082      		st Z,__zero_reg__
 173:main.c        ****             uart_rx_flag=1;
 226               	.LM11:
 227 00b0 81E0      		ldi r24,lo8(1)
 228 00b2 8093 0000 		sts uart_rx_flag,r24
 174:main.c        ****             uart_rx_cnt=0;
 230               	.LM12:
 231 00b6 1092 0000 		sts uart_rx_cnt.1709,__zero_reg__
 232 00ba 00C0      		rjmp .L8
 233               	.L7:
 175:main.c        ****         }else if (uart_rx_cnt<(uart_buffer_size-1)) {
 235               	.LM13:
 236 00bc 8F3F      		cpi r24,lo8(-1)
 237 00be 01F0      		breq .L8
 176:main.c        ****             uart_rx_buffer[uart_rx_cnt]=data;
 239               	.LM14:
 240 00c0 E82F      		mov r30,r24
 241 00c2 F0E0      		ldi r31,lo8(0)
 242 00c4 E050      		subi r30,lo8(-(uart_rx_buffer))
 243 00c6 F040      		sbci r31,hi8(-(uart_rx_buffer))
 244 00c8 9083      		st Z,r25
 177:main.c        ****             uart_rx_cnt++; // Zähler erhöhen
 246               	.LM15:
 247 00ca 8F5F      		subi r24,lo8(-(1))
 248 00cc 8093 0000 		sts uart_rx_cnt.1709,r24
 249               	.L8:
 250               	/* epilogue start */
 178:main.c        ****         }
 179:main.c        ****     }
 180:main.c        **** }
 252               	.LM16:
 253 00d0 FF91      		pop r31
 254 00d2 EF91      		pop r30
 255 00d4 9F91      		pop r25
 256 00d6 8F91      		pop r24
 257 00d8 0F90      		pop r0
 258 00da 0FBE      		out __SREG__,r0
 259 00dc 0F90      		pop r0
 260 00de 1F90      		pop __zero_reg__
 261 00e0 1895      		reti
 267               	.Lscope3:
 269               	.global	__vector_12
 271               	__vector_12:
 181:main.c        **** 
 182:main.c        **** 
 183:main.c        **** ISR(USART_UDRE_vect) {
 273               	.LM17:
 274               	.LFBB4:
 275 00e2 1F92      		push __zero_reg__
 276 00e4 0F92      		push r0
 277 00e6 0FB6      		in r0,__SREG__
 278 00e8 0F92      		push r0
 279 00ea 1124      		clr __zero_reg__
 280 00ec 8F93      		push r24
 281 00ee 9F93      		push r25
 282 00f0 EF93      		push r30
 283 00f2 FF93      		push r31
 284               	/* prologue: Signal */
 285               	/* frame size = 0 */
 184:main.c        ****     static char* uart_tx_p = uart_tx_buffer;    
 185:main.c        ****     uint8_t data;
 186:main.c        **** 
 187:main.c        ****     data = *uart_tx_p++;
 287               	.LM18:
 288 00f4 E091 0000 		lds r30,uart_tx_p.1721
 289 00f8 F091 0000 		lds r31,(uart_tx_p.1721)+1
 290 00fc 8191      		ld r24,Z+
 291 00fe F093 0000 		sts (uart_tx_p.1721)+1,r31
 292 0102 E093 0000 		sts uart_tx_p.1721,r30
 188:main.c        **** 
 189:main.c        ****     if (data == 0 ) {
 294               	.LM19:
 295 0106 8823      		tst r24
 296 0108 01F4      		brne .L10
 190:main.c        ****         UCSRB &= ~(1<<UDRIE);       // ja, dann UDRE Interrupt ausschalten
 298               	.LM20:
 299 010a 5598      		cbi 42-32,5
 191:main.c        ****         uart_tx_p = uart_tx_buffer; // Pointer zurücksetzen
 301               	.LM21:
 302 010c 80E0      		ldi r24,lo8(uart_tx_buffer)
 303 010e 90E0      		ldi r25,hi8(uart_tx_buffer)
 304 0110 9093 0000 		sts (uart_tx_p.1721)+1,r25
 305 0114 8093 0000 		sts uart_tx_p.1721,r24
 192:main.c        ****         uart_tx_flag = 1;           // Flag setzen, Übertragung beeendet
 307               	.LM22:
 308 0118 81E0      		ldi r24,lo8(1)
 309 011a 8093 0000 		sts uart_tx_flag,r24
 310 011e 00C0      		rjmp .L12
 311               	.L10:
 193:main.c        ****     }else{
 194:main.c        **** 	 UDR = data;                // nein, Daten senden
 313               	.LM23:
 314 0120 8CB9      		out 44-32,r24
 315               	.LBB24:
 316               	.LBB25:
 317               	.LBB26:
 318               	.LBB27:
 320               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** /** \file */
  40:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     \code
  42:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     \endcode
  44:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  45:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  53:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  60:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  62:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** */
  63:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  64:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** #endif
  68:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 322               	.LM24:
 323 0122 80E2      		ldi r24,lo8(20000)
 324 0124 9EE4      		ldi r25,hi8(20000)
 325               	/* #APP */
 326               	 ;  105 "/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h" 1
 327 0126 0197      		1: sbiw r24,1
 328 0128 01F4      		brne 1b
 329               	 ;  0 "" 2
 330               	/* #NOAPP */
 331               	.L12:
 332               	/* epilogue start */
 333               	.LBE27:
 334               	.LBE26:
 335               	.LBE25:
 336               	.LBE24:
 338               	.Ltext2:
 195:main.c        **** 	_delay_ms(10);
 196:main.c        **** 	}
 197:main.c        **** }
 340               	.LM25:
 341 012a FF91      		pop r31
 342 012c EF91      		pop r30
 343 012e 9F91      		pop r25
 344 0130 8F91      		pop r24
 345 0132 0F90      		pop r0
 346 0134 0FBE      		out __SREG__,r0
 347 0136 0F90      		pop r0
 348 0138 1F90      		pop __zero_reg__
 349 013a 1895      		reti
 355               	.Lscope4:
 358               	.global	get_string
 360               	get_string:
  47:main.c        **** void get_string(char *daten) {
 362               	.LM26:
 363               	.LFBB5:
 364               	/* prologue: function */
 365               	/* frame size = 0 */
 366 013c 9C01      		movw r18,r24
  48:main.c        ****    if (uart_rx_flag==1) {
 368               	.LM27:
 369 013e 8091 0000 		lds r24,uart_rx_flag
 370 0142 8130      		cpi r24,lo8(1)
 371 0144 01F4      		brne .L15
  49:main.c        ****       strcpy(daten, uart_rx_buffer);
 373               	.LM28:
 374 0146 C901      		movw r24,r18
 375 0148 60E0      		ldi r22,lo8(uart_rx_buffer)
 376 014a 70E0      		ldi r23,hi8(uart_rx_buffer)
 377 014c 00D0      		rcall strcpy
  50:main.c        ****       uart_rx_flag = 0;
 379               	.LM29:
 380 014e 1092 0000 		sts uart_rx_flag,__zero_reg__
 381               	.L15:
 382 0152 0895      		ret
 384               	.Lscope5:
 387               	.global	put_string
 389               	put_string:
  39:main.c        **** void put_string(char *daten) {
 391               	.LM30:
 392               	.LFBB6:
 393               	/* prologue: function */
 394               	/* frame size = 0 */
 395 0154 BC01      		movw r22,r24
  40:main.c        ****    if (uart_tx_flag == 1) {
 397               	.LM31:
 398 0156 8091 0000 		lds r24,uart_tx_flag
 399 015a 8130      		cpi r24,lo8(1)
 400 015c 01F4      		brne .L18
  41:main.c        ****       strcpy(uart_tx_buffer, daten);      
 402               	.LM32:
 403 015e 80E0      		ldi r24,lo8(uart_tx_buffer)
 404 0160 90E0      		ldi r25,hi8(uart_tx_buffer)
 405 0162 00D0      		rcall strcpy
  42:main.c        ****       uart_tx_flag = 0;                    
 407               	.LM33:
 408 0164 1092 0000 		sts uart_tx_flag,__zero_reg__
  43:main.c        ****       UCSRB |= (1<<UDRIE); 
 410               	.LM34:
 411 0168 559A      		sbi 42-32,5
 412               	.L18:
 413 016a 0895      		ret
 415               	.Lscope6:
 417               	.global	send_ok
 419               	send_ok:
  54:main.c        **** void send_ok(){
 421               	.LM35:
 422               	.LFBB7:
 423 016c DF93      		push r29
 424 016e CF93      		push r28
 425 0170 00D0      		rcall .
 426 0172 00D0      		rcall .
 427 0174 CDB7      		in r28,__SP_L__
 428 0176 DEB7      		in r29,__SP_H__
 429               	/* prologue: function */
 430               	/* frame size = 4 */
  56:main.c        **** 	message[0] = 'O';
 432               	.LM36:
 433 0178 8FE4      		ldi r24,lo8(79)
 434 017a 8983      		std Y+1,r24
  57:main.c        **** 	message[1] = 'K';
 436               	.LM37:
 437 017c 8BE4      		ldi r24,lo8(75)
 438 017e 8A83      		std Y+2,r24
  58:main.c        **** 	message[2] = '\n';
 440               	.LM38:
 441 0180 8AE0      		ldi r24,lo8(10)
 442 0182 8B83      		std Y+3,r24
  59:main.c        **** 	message[3] = '\r';
 444               	.LM39:
 445 0184 8DE0      		ldi r24,lo8(13)
 446 0186 8C83      		std Y+4,r24
  60:main.c        **** 	put_string(message);
 448               	.LM40:
 449 0188 CE01      		movw r24,r28
 450 018a 0196      		adiw r24,1
 451 018c 00D0      		rcall put_string
 452               	/* epilogue start */
  61:main.c        **** }
 454               	.LM41:
 455 018e 0F90      		pop __tmp_reg__
 456 0190 0F90      		pop __tmp_reg__
 457 0192 0F90      		pop __tmp_reg__
 458 0194 0F90      		pop __tmp_reg__
 459 0196 CF91      		pop r28
 460 0198 DF91      		pop r29
 461 019a 0895      		ret
 466               	.Lscope7:
 467               		.data
 468               	.LC0:
 469 0000 0A0D 00   		.string	"\n\r"
 470               		.text
 472               	.global	main
 474               	main:
  75:main.c        **** int main (void) {
 476               	.LM42:
 477               	.LFBB8:
 478 019c 9F92      		push r9
 479 019e AF92      		push r10
 480 01a0 BF92      		push r11
 481 01a2 CF92      		push r12
 482 01a4 DF92      		push r13
 483 01a6 EF92      		push r14
 484 01a8 FF92      		push r15
 485 01aa 0F93      		push r16
 486 01ac 1F93      		push r17
 487 01ae DF93      		push r29
 488 01b0 CF93      		push r28
 489 01b2 CDB7      		in r28,__SP_L__
 490 01b4 DEB7      		in r29,__SP_H__
 491 01b6 C054      		subi r28,lo8(-(-64))
 492 01b8 D040      		sbci r29,hi8(-(-64))
 493 01ba 0FB6      		in __tmp_reg__,__SREG__
 494 01bc F894      		cli
 495 01be DEBF      		out __SP_H__,r29
 496 01c0 0FBE      		out __SREG__,__tmp_reg__
 497 01c2 CDBF      		out __SP_L__,r28
 498               	/* prologue: function */
 499               	/* frame size = 64 */
  82:main.c        ****     DDRB = 0xFF;
 501               	.LM43:
 502 01c4 8FEF      		ldi r24,lo8(-1)
 503 01c6 87BB      		out 55-32,r24
  83:main.c        ****     DDRC = 0x00;
 505               	.LM44:
 506 01c8 14BA      		out 52-32,__zero_reg__
  84:main.c        **** 	PORTC = 0x00;
 508               	.LM45:
 509 01ca 15BA      		out 53-32,__zero_reg__
  88:main.c        **** 	ADMUX = 0x00;
 511               	.LM46:
 512 01cc 17B8      		out 39-32,__zero_reg__
  89:main.c        **** 	ADMUX |= (1<<REFS1)| (1<<REFS0); // 0b01000000; // interne Ref-Spannung, avcc, pc0 als adc
 514               	.LM47:
 515 01ce 87B1      		in r24,39-32
 516 01d0 806C      		ori r24,lo8(-64)
 517 01d2 87B9      		out 39-32,r24
  90:main.c        **** 	ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0);
 519               	.LM48:
 520 01d4 86B1      		in r24,38-32
 521 01d6 8768      		ori r24,lo8(-121)
 522 01d8 86B9      		out 38-32,r24
 103:main.c        ****     UBRRH = UBRR_VAL >> 8;
 524               	.LM49:
 525 01da 10BC      		out 64-32,__zero_reg__
 104:main.c        ****     UBRRL = UBRR_VAL & 0xFF;
 527               	.LM50:
 528 01dc 83E3      		ldi r24,lo8(51)
 529 01de 89B9      		out 41-32,r24
 105:main.c        ****     UCSRB = (1<<RXCIE) | (1<<RXEN) | (1<<TXEN); 
 531               	.LM51:
 532 01e0 88E9      		ldi r24,lo8(-104)
 533 01e2 8AB9      		out 42-32,r24
 107:main.c        ****     UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);      //Asynchron 8N1
 535               	.LM52:
 536 01e4 8EE8      		ldi r24,lo8(-114)
 537 01e6 80BD      		out 64-32,r24
 114:main.c        ****     sei();
 539               	.LM53:
 540               	/* #APP */
 541               	 ;  114 "main.c" 1
 542 01e8 7894      		sei
 543               	 ;  0 "" 2
 544               	/* #NOAPP */
 545 01ea 20E0      		ldi r18,lo8(0)
 120:main.c        ****             get_string(stringbuffer);
 547               	.LM54:
 548 01ec 7E01      		movw r14,r28
 549 01ee 0894      		sec
 550 01f0 E11C      		adc r14,__zero_reg__
 551 01f2 F11C      		adc r15,__zero_reg__
 552               	.LBB28:
 553               	.LBB29:
 554               	.LBB30:
 555               	.LBB31:
 557               	.Ltext3:
 559               	.LM55:
 560 01f4 30E2      		ldi r19,lo8(20000)
 561 01f6 A32E      		mov r10,r19
 562 01f8 3EE4      		ldi r19,hi8(20000)
 563 01fa B32E      		mov r11,r19
 564               	.LBE31:
 565               	.LBE30:
 566               	.LBE29:
 567               	.LBE28:
 568               	.LBB35:
 569               	.LBB36:
 570               	.LBB37:
 571               	.LBB38:
 572 01fc 98EC      		ldi r25,lo8(200)
 573 01fe C92E      		mov r12,r25
 574 0200 D12C      		mov r13,__zero_reg__
 575               	.LBE38:
 576               	.LBE37:
 577               	.LBE36:
 578               	.LBE35:
 580               	.Ltext4:
 140:main.c        **** 			stringbuffer[0] = 'N';
 582               	.LM56:
 583 0202 8EE4      		ldi r24,lo8(78)
 584 0204 982E      		mov r9,r24
 585               	.L35:
 119:main.c        ****         if (uart_rx_flag==1 && buffer_full==0) {
 587               	.LM57:
 588 0206 8091 0000 		lds r24,uart_rx_flag
 589 020a 8130      		cpi r24,lo8(1)
 590 020c 01F4      		brne .L22
 591 020e 2223      		tst r18
 592 0210 01F4      		brne .L38
 593               	.L23:
 120:main.c        ****             get_string(stringbuffer);
 595               	.LM58:
 596 0212 C701      		movw r24,r14
 597 0214 00D0      		rcall get_string
 598               	.L38:
 599 0216 21E0      		ldi r18,lo8(1)
 600               	.L22:
 128:main.c        **** 	if(stringbuffer[0] == 'S'){
 602               	.LM59:
 603 0218 8981      		ldd r24,Y+1
 604 021a 8335      		cpi r24,lo8(83)
 605 021c 01F4      		brne .L24
 129:main.c        **** 		if(stringbuffer[1] == '1'){
 607               	.LM60:
 608 021e 8A81      		ldd r24,Y+2
 609 0220 8133      		cpi r24,lo8(49)
 610 0222 01F4      		brne .L35
 130:main.c        **** 			PORTC |= (1<<5);
 612               	.LM61:
 613 0224 AD9A      		sbi 53-32,5
 614 0226 00C0      		rjmp .L39
 615               	.L24:
 136:main.c        **** 	}else if(stringbuffer[0] == 'U'){
 617               	.LM62:
 618 0228 8535      		cpi r24,lo8(85)
 619 022a 01F4      		brne .L26
 137:main.c        **** 		if(stringbuffer[1] == '1'){
 621               	.LM63:
 622 022c 8A81      		ldd r24,Y+2
 623 022e 8133      		cpi r24,lo8(49)
 624 0230 01F4      		brne .L35
 138:main.c        **** 			PORTC &= ~(1<<5);
 626               	.LM64:
 627 0232 AD98      		cbi 53-32,5
 628               	.L39:
 139:main.c        **** 			send_ok();
 630               	.LM65:
 631 0234 00D0      		rcall send_ok
 140:main.c        **** 			stringbuffer[0] = 'N';
 633               	.LM66:
 634 0236 9982      		std Y+1,r9
 635 0238 00C0      		rjmp .L37
 636               	.L26:
 143:main.c        **** 	}else if(stringbuffer[0] == 'G'){ // adc wert anfordern
 638               	.LM67:
 639 023a 8734      		cpi r24,lo8(71)
 640 023c 01F4      		brne .L27
 144:main.c        **** 		ADCSRA |= (1<<ADSC);  //single conversion mode ein
 642               	.LM68:
 643 023e 369A      		sbi 38-32,6
 644               	.L28:
 145:main.c        **** 		while(ADCSRA & (1<<ADSC));  //warten bis konvertierung abgeschlosen
 646               	.LM69:
 647 0240 3699      		sbic 38-32,6
 648 0242 00C0      		rjmp .L28
 146:main.c        **** 		sampleValue = ADCW;
 650               	.LM70:
 651 0244 84B1      		in r24,36-32
 652 0246 95B1      		in r25,(36)+1-32
 147:main.c        **** 		dtostrf( res2temp(adc2res(sampleValue)), 5, 2, stringbuffer );
 654               	.LM71:
 655 0248 00D0      		rcall adc2res
 656 024a 00D0      		rcall res2temp
 657 024c 45E0      		ldi r20,lo8(5)
 658 024e 22E0      		ldi r18,lo8(2)
 659 0250 8701      		movw r16,r14
 660 0252 00D0      		rcall dtostrf
 148:main.c        **** 		strcat(stringbuffer, "\n\r");
 662               	.LM72:
 663 0254 C701      		movw r24,r14
 664 0256 60E0      		ldi r22,lo8(.LC0)
 665 0258 70E0      		ldi r23,hi8(.LC0)
 666 025a 00D0      		rcall strcat
 667 025c 88EE      		ldi r24,lo8(1000)
 668 025e 93E0      		ldi r25,hi8(1000)
 669               	.L29:
 670               	.LBB42:
 671               	.LBB41:
 672               	.LBB40:
 673               	.LBB39:
 675               	.Ltext5:
 677               	.LM73:
 678 0260 F601      		movw r30,r12
 679               	/* #APP */
 680               	 ;  105 "/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h" 1
 681 0262 3197      		1: sbiw r30,1
 682 0264 01F4      		brne 1b
 683               	 ;  0 "" 2
 684               	/* #NOAPP */
 685               	.LBE39:
 686               	.LBE40:
 688               	.Ltext6:
   1:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5.2.1 2009/02/25 10:14:03 joerg_wunsch Exp $ */
  34:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #include <inttypes.h>
  39:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  40:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  41:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** /** \file */
  42:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  43:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     \code
  44:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  45:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  46:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  47:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     \endcode
  48:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  49:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  50:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  51:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  52:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     used.
  53:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  55:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  56:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  57:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  58:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  59:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  60:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  61:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  62:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  63:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  64:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  65:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  66:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  67:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  68:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  69:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  70:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     routines linked into the application.
  71:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  72:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  73:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  74:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  75:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** */
  77:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  78:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  79:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  80:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  81:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #endif
  82:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #ifndef F_CPU
  84:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  85:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  86:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  87:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #endif
  88:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  89:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  90:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  91:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** /**
  94:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    \ingroup util_delay
  95:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  96:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
  97:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  99:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 100:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
 101:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 102:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 
 103:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 104:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 105:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 106:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 107:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 108:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h ****  */
 109:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** void
 110:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 111:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** {
 112:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 113:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 114:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 115:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 		__ticks = 1;
 116:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 117:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 	{
 118:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 119:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 120:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 		while(__ticks)
 121:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 		{
 122:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 123:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 124:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 			__ticks --;
 690               	.LM74:
 691 0266 0197      		sbiw r24,1
 120:/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay.h **** 		while(__ticks)
 693               	.LM75:
 694 0268 01F4      		brne .L29
 695 026a 00C0      		rjmp .L36
 696               	.L27:
 697               	.LBE41:
 698               	.LBE42:
 699               	.LBB43:
 700               	.LBB34:
 701               	.LBB33:
 702               	.LBB32:
 704               	.Ltext7:
 706               	.LM76:
 707 026c C501      		movw r24,r10
 708               	/* #APP */
 709               	 ;  105 "/usr/lib/gcc/avr/4.3.5/../../../avr/include/util/delay_basic.h" 1
 710 026e 0197      		1: sbiw r24,1
 711 0270 01F4      		brne 1b
 712               	 ;  0 "" 2
 713               	/* #NOAPP */
 714               	.LBE32:
 715               	.LBE33:
 716               	.LBE34:
 717               	.LBE43:
 719               	.Ltext8:
 155:main.c        **** 	        if (uart_tx_flag==1 && buffer_full==1) {
 721               	.LM77:
 722 0272 8091 0000 		lds r24,uart_tx_flag
 723 0276 8130      		cpi r24,lo8(1)
 724 0278 01F4      		brne .L35
 725 027a 2130      		cpi r18,lo8(1)
 726 027c 01F0      		breq .+2
 727 027e 00C0      		rjmp .L35
 156:main.c        **** 	            strcat(stringbuffer, "\n\r");
 729               	.LM78:
 730 0280 C701      		movw r24,r14
 731 0282 60E0      		ldi r22,lo8(.LC0)
 732 0284 70E0      		ldi r23,hi8(.LC0)
 733 0286 00D0      		rcall strcat
 734               	.L36:
 157:main.c        **** 	            put_string(stringbuffer); // zurücksenden
 736               	.LM79:
 737 0288 C701      		movw r24,r14
 738 028a 00D0      		rcall put_string
 739               	.L37:
 740 028c 20E0      		ldi r18,lo8(0)
 741 028e 00C0      		rjmp .L35
 759               	.Lscope8:
 760               	.global	uart_rx_flag
 761               	.global	uart_rx_flag
 762               		.section .bss
 765               	uart_rx_flag:
 766 0000 00        		.skip 1,0
 767               	.global	uart_tx_flag
 768               		.data
 771               	uart_tx_flag:
 772 0003 01        		.byte	1
 775               	uart_tx_p.1721:
 776 0004 0000      		.word	uart_tx_buffer
 777               		.lcomm uart_rx_cnt.1709,1
 778               		.comm uart_rx_buffer,256,1
 779               		.comm uart_tx_buffer,256,1
 786               		.text
 788               	.Letext0:
 789               	.global __do_copy_data
 790               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cckCjlak.s:2      *ABS*:0000003f __SREG__
     /tmp/cckCjlak.s:3      *ABS*:0000003e __SP_H__
     /tmp/cckCjlak.s:4      *ABS*:0000003d __SP_L__
     /tmp/cckCjlak.s:5      *ABS*:00000034 __CCP__
     /tmp/cckCjlak.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cckCjlak.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cckCjlak.s:92     .text:00000000 adc2res
     /tmp/cckCjlak.s:156    .text:0000005e res2temp
     /tmp/cckCjlak.s:190    .text:00000082 __vector_11
     /tmp/cckCjlak.s:765    .bss:00000000 uart_rx_flag
                             .bss:00000001 uart_rx_cnt.1709
                            *COM*:00000100 uart_rx_buffer
     /tmp/cckCjlak.s:271    .text:000000e2 __vector_12
     /tmp/cckCjlak.s:775    .data:00000004 uart_tx_p.1721
                            *COM*:00000100 uart_tx_buffer
     /tmp/cckCjlak.s:771    .data:00000003 uart_tx_flag
     /tmp/cckCjlak.s:360    .text:0000013c get_string
     /tmp/cckCjlak.s:389    .text:00000154 put_string
     /tmp/cckCjlak.s:419    .text:0000016c send_ok
     /tmp/cckCjlak.s:474    .text:0000019c main

UNDEFINED SYMBOLS
__floatsisf
__mulsf3
__divsf3
__subsf3
__fixsfsi
strcpy
dtostrf
strcat
__do_copy_data
__do_clear_bss
